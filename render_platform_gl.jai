/*
Implementation of OpenGL 3.3 core.

This should provide platform-agnostic functionality to render.jai.
Its implementation should be as simple as possible, but its interface can be as complex as necessary.
It is okay if that causes render.jai's implementation to be more complex.
Platform-specific complexity is much worse than non-platform-specific complexity.
This file's functionality is dictated by what render.jai needs.
*/

render_platform_init :: () {
  print("GL: %, %, OpenGL v%\n", to_string(glGetString(GL_RENDERER)), to_string(glGetString(GL_VENDOR)), to_string(glGetString(GL_VERSION)));
  
  version_major, version_minor : GLint;
  glGetIntegerv(GL_MAJOR_VERSION, *version_major);
  glGetIntegerv(GL_MINOR_VERSION, *version_minor);
  assert(version_major >= 3);
  assert(version_minor >= 3 || version_major > 3);
  
  gl_load(*gl);
  
  glGenVertexArrays(1, *vao);
  glBindVertexArray(vao);
  
  programs = build_all_programs();
  
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  
  glGenFramebuffers(1, *secondary_frame_buffer);
  assert(secondary_frame_buffer != 0);
  glGenRenderbuffers(1, *secondary_depth_buffer);
  assert(secondary_depth_buffer != 0);
  
  check_error();
}

render_platform_set_output_to_display :: (display_width: int, display_height: int) {
  glBindFramebuffer(GL_FRAMEBUFFER, 0);
  glViewport(0, 0, cast(u32) display_width, cast(u32) display_height);
}

render_platform_set_output_to_texture :: (texture: u32) {
  glBindTexture(GL_TEXTURE_2D, texture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  
  glBindFramebuffer(GL_FRAMEBUFFER, secondary_frame_buffer);
  glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, texture, 0);
  draw_buffers :: u32.[GL_COLOR_ATTACHMENT0];
  glDrawBuffers(draw_buffers.count, draw_buffers.data);
  
  // Getting the texture size from OpenGL might not be efficient, and it might not be portable to Vulkan etc.
  tex_width, tex_height : s32 = ---;
  glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, *tex_width);
  glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, *tex_height);
  glViewport(0, 0, cast(u32) tex_width, cast(u32) tex_height);
  
  // Set depth buffer. This might be inefficient.
  glBindRenderbuffer(GL_RENDERBUFFER, secondary_depth_buffer);
  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, cast(u32) tex_width, cast(u32) tex_height);
  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, secondary_depth_buffer);
  
  check_error();
}

render_platform_clear_all :: (color: v3) {
  using color;
  glClearColor(x, y, z, 1);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}

render_platform_clear_depth_buffer :: () {
  glClear(GL_DEPTH_BUFFER_BIT);
}

Render_Platform_Shader :: Render_Platform_Shader_Autogenerated;

render_platform_set_shader :: (shader: Render_Platform_Shader) {
  active_shader = shader;
  glUseProgram(programs[active_shader].handle);
}

render_platform_enable_wireframe :: (enable: bool) {
  if enable {
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  } else {
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
  }
}

Platform_Vertex_Buffer :: struct {
  vertices_count : GLsizei;
  position_buffer : GLuint;
  normal_buffer : GLuint;
  tex_coord_buffer : GLuint;
  texture : u32;
  color : v4;
  // If this struct gets big, consider allocing and returning a pointer to it from make_vertex_buffer()
}

render_platform_make_vertex_buffer :: (
  positions: []v3,
  normals: []v3,
  tex_coords: []v2,
  texture: u32,
  color: v4) -> Platform_Vertex_Buffer {
  
  vbuffer : Platform_Vertex_Buffer;
  
  // rwtodo: can combine these into one call.
  glGenBuffers(1, *vbuffer.position_buffer);
  glGenBuffers(1, *vbuffer.normal_buffer);
  glGenBuffers(1, *vbuffer.tex_coord_buffer);
  
  render_platform_set_vertices(*vbuffer, positions, normals, tex_coords);
  vbuffer.texture = texture;
  vbuffer.color = color;
  
  check_error();
  return vbuffer;
}

render_platform_delete_vertex_buffer :: (vbuffer: Platform_Vertex_Buffer) {
  glDeleteBuffers(1, *vbuffer.position_buffer);
  glDeleteBuffers(1, *vbuffer.normal_buffer);
  glDeleteBuffers(1, *vbuffer.tex_coord_buffer);
  
  check_error();
}

render_platform_set_vertices :: (vbuffer: *Platform_Vertex_Buffer, positions: []v3, normals: []v3, tex_coords: []v2) {
  assert(positions.count >= 3);
  assert(positions.count == normals.count);
  assert(positions.count == tex_coords.count);
  
  glBindBuffer(GL_ARRAY_BUFFER, vbuffer.position_buffer);
  vbuffer.vertices_count = cast(GLsizei) positions.count;
  num_bytes_v3 := size_of(v3) * vbuffer.vertices_count;
  num_bytes_v2 := size_of(v2) * vbuffer.vertices_count;
  glBufferData(GL_ARRAY_BUFFER, num_bytes_v3, positions.data, GL_STATIC_DRAW);
  
  glBindBuffer(GL_ARRAY_BUFFER, vbuffer.normal_buffer);
  glBufferData(GL_ARRAY_BUFFER, num_bytes_v3, normals.data, GL_STATIC_DRAW);
  
  glBindBuffer(GL_ARRAY_BUFFER, vbuffer.tex_coord_buffer);
  glBufferData(GL_ARRAY_BUFFER, num_bytes_v2, tex_coords.data, GL_STATIC_DRAW);
  
  check_error(); // rwtodo: don't call this every frame in release mode.
}

render_platform_vertex_buffer :: (vbuffer: Platform_Vertex_Buffer, matrix: m4) {
  // rwtodo: I think glEnableVertexAttribArray and glVertexAttribPointer can be done at init or after binding the VAO, or after linking each program.
  
  program := programs[active_shader];
  
  pos_location := glGetAttribLocation(program.handle, "vert_pos_in");
  assert(pos_location >= 0);
  glBindBuffer(GL_ARRAY_BUFFER, vbuffer.position_buffer);
  glEnableVertexAttribArray(cast(u32) pos_location);
  glVertexAttribPointer(cast(u32) pos_location, 3, GL_FLOAT, GL_FALSE, 0, cast(*void) 0);
  
  normal_location := glGetAttribLocation(program.handle, "vert_normal_in");
  if normal_location >= 0 {
    glBindBuffer(GL_ARRAY_BUFFER, vbuffer.normal_buffer);
    glEnableVertexAttribArray(cast(u32) normal_location);
    glVertexAttribPointer(cast(u32) normal_location, 3, GL_FLOAT, GL_FALSE, 0, cast(*void) 0);
  }
  
  tex_coord_location := glGetAttribLocation(program.handle, "vert_tex_coord_in");
  if tex_coord_location >= 0 {
    glBindBuffer(GL_ARRAY_BUFFER, vbuffer.tex_coord_buffer);
    glEnableVertexAttribArray(cast(u32) tex_coord_location);
    glVertexAttribPointer(cast(u32) tex_coord_location, 2, GL_FLOAT, GL_FALSE, 0, cast(*void) 0);
  }
  
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, vbuffer.texture);
  glUniform1i(program.color_texture_uniform_location, 0); // 0 means GL_TEXTURE0
  
  using vbuffer;
  glUniform4f(program.color_uniform_location, color.x, color.y, color.z, color.w);
  
  glUniformMatrix4fv(program.matrix_uniform_location, 1, GL_FALSE, matrix.floats.data);
  
  glDrawArrays(GL_TRIANGLES, 0, vbuffer.vertices_count);
}

render_platform_enable_depth_testing :: (test: bool) {
  if test {
    glEnable(GL_DEPTH_TEST);
  } else {
    glDisable(GL_DEPTH_TEST);
  }
}

render_platform_enable_clockwise_culling :: (cull: bool) {
  if cull {
    glFrontFace(GL_CCW);
    glCullFace(GL_BACK);
    glEnable(GL_CULL_FACE);
  } else {
    glDisable(GL_CULL_FACE);
  }
}

INVALID_TEXTURE : u32 : 0;

render_platform_make_texture :: (width: int, height: int) -> u32 #must { // rwtodo: not used
  texture : GLuint;
  glGenTextures(1, *texture);
  assert(texture != 0);
  
  glBindTexture(GL_TEXTURE_2D, texture);
  
  glTexImage2D(
    GL_TEXTURE_2D,
    0,
    GL_RGBA,
    cast(u32) width,
    cast(u32) height,
    0,
    GL_RGBA,
    GL_FLOAT,
    null);
  
  
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  
  // Linear filtering
  // rwtodo: Since the render-to-texture code sets filtering to NEAREST, I should probably set filtering at the render() call.
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  
  check_error();
  
  return texture;
}

render_platform_load_texture :: (width: int, height: int, pixels: []v4) -> u32 #must {
  texture : GLuint;
  glGenTextures(1, *texture);
  assert(texture != 0);
  
  glBindTexture(GL_TEXTURE_2D, texture);
  
  assert(width*height == pixels.count);
  glTexImage2D(
    GL_TEXTURE_2D,
    0,
    GL_RGBA,
    cast(u32) width,
    cast(u32) height,
    0,
    GL_RGBA,
    GL_FLOAT,
    pixels.data);
  
  glGenerateMipmap(GL_TEXTURE_2D);
  
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  
  // Linear filtering
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  
  check_error();
  
  return texture;
}

#scope_file ////////////////////////////////////////////////////////////////////////////////////////

shaders_directory :: "shaders";

vao : GLuint;

compile_shader :: (shader_type: GLenum, shader_source: string) -> GLuint #must {
  shader := glCreateShader(shader_type);
  
  shader_length : GLint = xx shader_source.count;
  glShaderSource(shader, 1, *shader_source.data, *shader_length);
  glCompileShader(shader);
  
  result : GLint;
  info_length : s32;
  glGetShaderiv(shader, GL_COMPILE_STATUS, *result);
  glGetShaderiv(shader, GL_INFO_LOG_LENGTH, *info_length);
  
  if info_length > 0 {
    log : [512]u8;
    glGetShaderInfoLog(shader, 512, null, log.data);
    print("SHADER: %\n", to_string(log.data));
    exit(1);
  }
  
  return shader;
}

build_program :: (vert_text: string, frag_text: string) -> Program #must {
  vert_shader := compile_shader(GL_VERTEX_SHADER, vert_text); defer glDeleteShader(vert_shader);
  frag_shader := compile_shader(GL_FRAGMENT_SHADER, frag_text); defer glDeleteShader(frag_shader);
  
  program : Program = ---;
  program.handle = glCreateProgram();
  assert(program.handle != 0);
  
  glAttachShader(program.handle, vert_shader);
  glAttachShader(program.handle, frag_shader);
  glLinkProgram(program.handle);
  
  result : GLint;
  info_length : s32;
  glGetProgramiv(program.handle, GL_LINK_STATUS, *result);
  glGetProgramiv(program.handle, GL_INFO_LOG_LENGTH, *info_length);
  
  if info_length > 0 {
    log : [512]u8;
    glGetProgramInfoLog(program.handle, 512, null, log.data);
    print("SHADER PROGRAM: %\n", to_string(log.data));
    exit(1);
  }
  
  print("GL: Program contains uniforms:");
  program.color_uniform_location = glGetUniformLocation(program.handle, "vertex_buffer_color");
  if program.color_uniform_location != -1 {
    print(" vertex_buffer_color");
  }
  
  program.matrix_uniform_location = glGetUniformLocation(program.handle, "matrix");
  if program.matrix_uniform_location != -1 {
    print(" matrix");
  }
  
  program.color_texture_uniform_location = glGetUniformLocation(program.handle, "color_texture");
  if program.color_texture_uniform_location != -1 {
    print(" color_texture");
  }
  
  print("\n");
  
  check_error();
  return program;
}

build_all_programs :: () -> []Program #must {
  programs_name_strs := type_info(Render_Platform_Shader).names;
  programs_enum_values := type_info(Render_Platform_Shader).values;
  
  programs := NewArray(programs_enum_values.count, Program, initialized=false);
  string_builder : String_Builder;
  string_builder.allocator = __temporary_allocator;
  
  append(*string_builder, shaders_directory);
  append(*string_builder, "/common.glsl");
  common_shader_code_path := builder_to_string(*string_builder, allocator=__temporary_allocator);
  common_shader_code := assert_and_read_entire_file(common_shader_code_path);
  reset(*string_builder);
  
  for programs_enum_values {
    // rwsubltodo: couldn't autocomplete it_index
    assert(it == it_index); // Ensure that nothing funky is going on with explicit enum values
    
    program_name_lowercase := t_copy(programs_name_strs[it]);
    to_lower(program_name_lowercase);
    
    append(*string_builder, shaders_directory);
    append(*string_builder, "/");
    append(*string_builder, program_name_lowercase);
    append(*string_builder, ".vert");
    
    vert_path := builder_to_string(*string_builder, allocator=__temporary_allocator);
    reset(*string_builder);
    
    append(*string_builder, shaders_directory);
    append(*string_builder, "/");
    append(*string_builder, program_name_lowercase);
    append(*string_builder, ".frag");
    
    frag_path := builder_to_string(*string_builder, allocator=__temporary_allocator);
    reset(*string_builder);
    
    vert_source := join(common_shader_code, assert_and_read_entire_file(vert_path), separator="\n");
    frag_source := join(common_shader_code, assert_and_read_entire_file(frag_path), separator="\n");
    
    print("GL: Building program '%'\n", program_name_lowercase);
    programs[it] = build_program(vert_source, frag_source);
    
    free(vert_source.data);
    free(frag_source.data);
  }
  
  return programs;
}

t_get_shader_names :: () -> []string {
  shader_files := file_list(shaders_directory);
  unique_shader_names : [..]string;
  unique_shader_names.allocator = __temporary_allocator;
  
  for shader_files {
    shader_file_path : string = ---;
    
    if ends_with_nocase(it, ".vert") {
      shader_file_path.count = it.count - ".vert".count;
      shader_file_path.data = it.data;
    } else if ends_with_nocase(it, ".frag") {
      shader_file_path.count = it.count - ".frag".count;
      shader_file_path.data = it.data;
    } else {
      continue;
    }
    
    shader_name := shader_file_path;
    
    // Remove directory prefix
    shader_name.data += shaders_directory.count + 1;
    shader_name.count -= shaders_directory.count + 1;
    
    if !contains(unique_shader_names, shader_name) {
      array_add(*unique_shader_names, shader_name);
    }
  }
  
  return unique_shader_names;
}

autogenerate_shader_enum :: () -> string {
  members := t_get_shader_names();
  
  for *members {
    to_upper_in_place(<<it);
  }
  
  builder : String_Builder;
  append(*builder, "Render_Platform_Shader_Autogenerated :: enum {\n");
  
  for members {
    append(*builder, it);
    append(*builder, ";\n");
  }
  
  append(*builder, "}");
  
  return builder_to_string(*builder);
}

#insert #run autogenerate_shader_enum();

Program :: struct {
  handle : GLuint;
  color_uniform_location : GLint;
  matrix_uniform_location : GLint;
  color_texture_uniform_location : GLint;
}

programs : []Program;
active_shader : Render_Platform_Shader;

secondary_frame_buffer : GLuint;
secondary_depth_buffer : GLuint;

check_error :: () {
  error := glGetError();
  if error != GL_NO_ERROR {
    print("GL ERROR: %\n", error);
    assert(false);
  }
}

#run compiler_set_type_info_flags(GL_Procedures, .NO_SIZE_COMPLAINT);
#import "GL";
#import "String"; // rwsubltodo: doublequotes don't work correctly when typing this.